import logging
import time
from typing import Optional

from google import genai
from google.genai import types
from sqlalchemy import select

from supernote.server.config import ServerConfig
from supernote.server.constants import CACHE_BUCKET
from supernote.server.db.models.note_processing import NotePageContentDO, SystemTaskDO
from supernote.server.db.session import DatabaseSessionManager
from supernote.server.services.file import FileService
from supernote.server.services.processor_modules import ProcessorModule
from supernote.server.utils.paths import get_page_png_path

logger = logging.getLogger(__name__)


class GeminiOcrModule(ProcessorModule):
    """Module responsible for extracting text from note pages using Gemini OCR.

    This module performs the following:
    1.  Reads the page PNG from Blob Storage (generated by PngConversionModule).
    2.  Sends the image to the Gemini API (using the configured `v1alpha` model).
    3.  Updates the `NotePageContentDO` with the transcribed text.
    4.  Updates the `SystemTaskDO` status to COMPLETED.
    """

    def __init__(self, file_service: FileService, config: ServerConfig) -> None:
        self.file_service = file_service
        self.config = config

    @property
    def name(self) -> str:
        return "GeminiOcrModule"

    @property
    def task_type(self) -> str:
        return "OCR_EXTRACTION"

    async def run_if_needed(
        self,
        file_id: int,
        session_manager: DatabaseSessionManager,
        page_index: Optional[int] = None,
    ) -> bool:
        if page_index is None:
            return False

        task_key = f"page_{page_index}"
        async with session_manager.session() as session:
            task = (
                (
                    await session.execute(
                        select(SystemTaskDO)
                        .where(SystemTaskDO.file_id == file_id)
                        .where(SystemTaskDO.task_type == self.task_type)
                        .where(SystemTaskDO.key == task_key)
                    )
                )
                .scalars()
                .first()
            )
            if task and task.status == "COMPLETED":
                return False

            # Check if PNG exists (Prerequisite)
            png_path = get_page_png_path(file_id, page_index)
            if not await self.file_service.blob_storage.exists(CACHE_BUCKET, png_path):
                return False

        return True

    async def process(
        self,
        file_id: int,
        session_manager: DatabaseSessionManager,
        page_index: Optional[int] = None,
        **kwargs: object,
    ) -> None:
        if page_index is None:
            return

        logger.info(f"Starting OCR for file {file_id} page {page_index}")

        # 1. Get PNG Content
        png_path = get_page_png_path(file_id, page_index)
        try:
            png_data = b""
            async for chunk in self.file_service.blob_storage.get(
                CACHE_BUCKET, png_path
            ):
                png_data += chunk
        except Exception as e:
            logger.error(f"Failed to read PNG for {file_id} page {page_index}: {e}")
            await self._update_task_status(
                session_manager, file_id, page_index, "FAILED", str(e)
            )
            return

        # 2. Call Gemini API
        try:
            if not self.config.gemini_api_key:
                raise ValueError("GEMINI_API_KEY not configured")

            client = genai.Client(
                api_key=self.config.gemini_api_key,
                http_options={"api_version": "v1alpha"},
            )

            model_id = self.config.gemini_ocr_model

            prompt = (
                "Transcribe the handwritten text in this image. Output ONLY the text."
            )

            response = client.models.generate_content(
                model=model_id,
                contents=[
                    types.Content(
                        parts=[
                            types.Part(text=prompt),
                            types.Part(
                                inline_data=types.Blob(
                                    mime_type="image/png",
                                    data=png_data,
                                ),
                                media_resolution={"level": "media_resolution_high"},  # type: ignore[arg-type]
                            ),
                        ]
                    )
                ],
            )

            text_content = response.text if response.text else ""

        except Exception as e:
            logger.error(f"Gemini API failed for {file_id} page {page_index}: {e}")
            await self._update_task_status(
                session_manager, file_id, page_index, "FAILED", str(e)
            )
            return

        # 3. Save Result
        async with session_manager.session() as session:
            # Update NotePageContentDO
            content = (
                (
                    await session.execute(
                        select(NotePageContentDO)
                        .where(NotePageContentDO.file_id == file_id)
                        .where(NotePageContentDO.page_index == page_index)
                    )
                )
                .scalars()
                .first()
            )

            if content:
                content.text_content = text_content
            else:
                # Should accept exist if PageHashing ran, but safeguard
                logger.warning(
                    f"NotePageContentDO missing for {file_id} page {page_index} during OCR"
                )
                # Could create, but lacks hash. Skip for now or let Hashing run.

            await session.commit()

        # 4. Update Task Status
        await self._update_task_status(
            session_manager, file_id, page_index, "COMPLETED"
        )
        logger.info(f"Completed OCR for file {file_id} page {page_index}")

    async def _update_task_status(
        self,
        session_manager: DatabaseSessionManager,
        file_id: int,
        page_index: int,
        status: str,
        error: Optional[str] = None,
    ) -> None:
        task_key = f"page_{page_index}"
        async with session_manager.session() as session:
            existing_task = (
                (
                    await session.execute(
                        select(SystemTaskDO)
                        .where(SystemTaskDO.file_id == file_id)
                        .where(SystemTaskDO.task_type == self.task_type)
                        .where(SystemTaskDO.key == task_key)
                    )
                )
                .scalars()
                .first()
            )

            if not existing_task:
                existing_task = SystemTaskDO(
                    file_id=file_id,
                    task_type=self.task_type,
                    key=task_key,
                    status=status,
                    last_error=error,
                )
                session.add(existing_task)
            else:
                existing_task.status = status
                existing_task.last_error = error
                existing_task.update_time = int(time.time() * 1000)

            await session.commit()
