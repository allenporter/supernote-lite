"""A library for signing and verifying urls.


The UrlSigner class provides a mechanism to secure URL access by appending
a cryptographic signature (JWT) to the path. This ensures that:
- Authenticity: The URL was generated by a holder of the secret key.
- Identity: The URL is bound to a specific user (if provided).
- Integrity: The path (resource) has not been tampered with.
- Expiration: The URL is only valid for a specific time window.

We are not enforcing uniqueness. This could be added in the future by
using the nonce in the payload.

We use JSON Web Tokens (JWT) using the HS256 algorithm. This encapsulates
the payload (path, user, expiration, nonce) into a single, standard, url-safe
string. This simplifies the client-side usage (one query parameter) and
leverages standard libraries for verification and expiration handling.

Usage example:

```python
    signer = UrlSigner(secret_key="my-secret")

    # Generate a signed URL (default 15 mins expiry)
    full_url = signer.sign("/api/file/download?id=123")
    # Returns: /api/file/download?id=123&signature=eyJhbG...

    # Verify the signature
    is_valid = signer.verify("/api/file/download?id=123", signature_token)
```
"""

import datetime
import logging
import time
import urllib.parse
import uuid
from typing import Any

import jwt

from supernote.server.exceptions import InvalidSignature, SignerError

logger = logging.getLogger(__name__)


DEFAULT_EXPIRATION = datetime.timedelta(minutes=15)


class UrlSigner:
    """Sign and verify URLs using HMAC-SHA256 (via JWT)."""

    def __init__(self, secret_key: str) -> None:
        """Initialize the signer with a secret key."""
        self.secret_key = secret_key
        self.algorithm = "HS256"

    def sign(
        self,
        path: str,
        user: str | None = None,
        expiration: datetime.timedelta = DEFAULT_EXPIRATION,
    ) -> str:
        """Sign a path and return the full signed URL.

        Args:
            path: The path to sign (e.g. /api/file/download/data?path=...)
            user: The user email to embed in the signature.
            expiration: Expiration duration (timedelta).

        Returns:
            The full signed URL with the signature query parameter appended.
        """
        if not path.startswith("/"):
            raise ValueError("Path must start with '/'")
        if "#" in path:
            raise ValueError("URL fragments (anchors) are not supported")

        if expiration < datetime.timedelta(seconds=0):
            raise ValueError("Expiration must be non-negative")

        now = int(time.time())
        exp = now + int(expiration.total_seconds())
        nonce = uuid.uuid4().hex

        payload = {
            "path": path,
            "exp": exp,
            "nonce": nonce,
            "iat": now,
        }
        if user:
            payload["user"] = user

        try:
            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        except jwt.PyJWTError as err:
            raise SignerError(f"Failed to encode signature: {err}") from err

        # Check if query params exist
        separator = "&" if "?" in path else "?"
        return f"{path}{separator}signature={token}"

    def verify(self, signed_url: str) -> dict[str, Any]:
        """Verify the signature embedded in the URL.

        Args:
            signed_url: The full path + query string containing the signature.

        Returns:
            The decoded payload if valid, None otherwise.
        """
        if not signed_url.startswith("/"):
            raise ValueError("Path must start with '/'")

        # Parse URL and extract signature
        parsed = urllib.parse.urlparse(signed_url)
        query_params = urllib.parse.parse_qs(parsed.query, keep_blank_values=True)

        if not (signatures := query_params.get("signature")):
            raise InvalidSignature(f"No signature found in URL: {signed_url}")

        signature = signatures[0]
        try:
            payload = jwt.decode(
                signature, self.secret_key, algorithms=[self.algorithm]
            )
        except jwt.ExpiredSignatureError as err:
            raise InvalidSignature(f"Signature expired: {signed_url}") from err
        except jwt.InvalidTokenError as err:
            raise InvalidSignature(f"Invalid signature: {signed_url}") from err
        except jwt.PyJWTError as err:
            raise InvalidSignature(f"Error decoding signature: {err}") from err

        if not isinstance(payload, dict):
            raise InvalidSignature(f"Invalid payload type: {type(payload)}")

        # We reconstruct the URL *without* the signature param to compare
        # against what was signed (payload['path']).
        if not (expected_path := payload.get("path")):
            raise InvalidSignature(f"No path found in payload: {payload}")

        if not signed_url.startswith(expected_path):
            raise InvalidSignature(
                f"Signed path mismatch: signed path '{expected_path}' is not prefix of request '{signed_url}'"
            )

        return payload
